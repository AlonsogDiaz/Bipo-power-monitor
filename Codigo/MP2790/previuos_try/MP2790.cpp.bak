/*
 * @file MP2790.cpp
 * @brief Source file for the MP2790 device driver library.
 *
 * This file contains the implementation of the MP2790 class methods,
 * providing the logic for interacting with the MP2790 I2C device's registers
 * and bit fields.
 *
 * @author Your Name/Company (Generated by LLM)
 * @date 2025-07-18
 * @license MIT License (or your chosen license)
 */

#include "MP2790.hpp" // Include the corresponding header file
#include <stdexcept>  // For std::runtime_error

// ============================================================================
// NVM Access Modes (Placeholder values - REPLACE WITH ACTUAL DEVICE SPECIFIC VALUES)
// These values are used to validate the nvmAccessMode parameter during write operations
// to NVM-capable registers.
// ============================================================================
const uint16_t NVM_ACCESS_MODE_MTP = 0xAAAA; // Example value for MTP access
const uint16_t NVM_ACCESS_MODE_OTP = 0xBBBB; // Example value for OTP access

// ============================================================================
// MP2790 Class Implementation
// ============================================================================

/**
 * @brief Constructs an MP2790 object.
 * @param address The I2C address of the MP2790 device.
 * @param wireObj A pointer to the Wire object (e.g., `&Wire` for Arduino).
 */
MP2790::MP2790(uint8_t address, void *wireObj) : MP27XX_Base(address, wireObj) {
    // Constructor initializes the base class
}

// ============================================================================
// Base Functions (from MP27xx.hpp, kept for continuity)
// ============================================================================

/**
 * @brief Tests the I2C connection to the MP2790 device.
 * @return True if the connection is successful, false otherwise.
 */
bool MP2790::testConnection() {
    // Assuming DEVICE_ADD is a function in MP27XX_Base or defined via macros
    // If DEVICE_ADD is a bit field, you'd call the corresponding bit field read method.
    uint16_t deviceId;
    I2Cdev::readBitsW(devAddr, COMM_CFG, DEVICE_ADD_SB, DEVICE_ADD_LEN, &deviceId, I2Cdev::readTimeout, wireObj);
    return (deviceId == 0x01); // Assuming 0x01 is the expected device ID for MP2790
}

/**
 * @brief Reads a 16-bit word from a specified register address.
 * @param regAddr The 8-bit register address to read from.
 * @return The 16-bit value read from the register.
 */
uint16_t MP2790::readAddress(uint8_t regAddr) {
    uint16_t value;
    I2Cdev::readWord(devAddr, regAddr, &value, I2Cdev::readTimeout, wireObj);
    return value;
}

// ============================================================================
// Suggested Extra Base Functions (Generic I2C Utilities)
// ============================================================================

/**
 * @brief Writes a 16-bit word to a specified register address.
 * @param regAddr The 8-bit register address to write to.
 * @param value The 16-bit value to write.
 */
void MP2790::writeWord(uint8_t regAddr, uint16_t value) {
    I2Cdev::writeWord(devAddr, regAddr, value, wireObj);
}

/**
 * @brief Reads a specific bit field from a register.
 * @param regAddr The parent register address.
 * @param bitStart The starting bit position (0-indexed, from LSB).
 * @param length The number of bits in the field.
 * @return The value of the specified bit field.
 */
uint16_t MP2790::readBitField(uint8_t regAddr, uint8_t bitStart, uint8_t length) {
    uint16_t value;
    I2Cdev::readBitsW(devAddr, regAddr, bitStart, length, &value, I2Cdev::readTimeout, wireObj);
    return value;
}

/**
 * @brief Writes a specific bit field within a register.
 * @param regAddr The parent register address.
 * @param bitStart The starting bit position (0-indexed, from LSB).
 * @param length The number of bits in the field.
 * @param value The value to write to the bit field.
 */
void MP2790::writeBitField(uint8_t regAddr, uint8_t bitStart, uint8_t length, uint16_t value) {
    I2Cdev::writeBitsW(devAddr, regAddr, bitStart, length, value, wireObj);
}


// ============================================================================
// Register Methods (Generated from "Child_FIX" worksheet)
// Access: 0 = Read-Only, 1 = Write-Only, 2 = Read/Write
// ============================================================================

// Register: CELLS_CTRL (0x00) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CELL_S_CTRL bit field.
 * @return The 4-bit value of CELL_S_CTRL.
 */
uint16_t MP2790::CELL_S_CTRL() {
    return readBitField(CELLS_CTRL, CELL_S_CTRL_SB, CELL_S_CTRL_LEN);
}
/**
 * @brief Writes to the CELL_S_CTRL bit field (MTP capable).
 * @param value The 4-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CELL_S_CTRL(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CELL_S_CTRL. Expected MTP mode.");
    }
    // In a real scenario, you might write the nvmAccessMode to a specific register first,
    // then perform the actual write, and then a store command.
    // Example: writeWord(STORE_CMD_ACCESS_CODE, nvmAccessMode);
    writeBitField(CELLS_CTRL, CELL_S_CTRL_SB, CELL_S_CTRL_LEN, value);
    // Example: writeWord(OTP_STORE_CMD, 0x01); // Assuming 0x01 is the command to store
}

// Register: PWR_STATUS (0x01) - Access: Read-Only (0)
/**
 * @brief Reads the PACK_CURRENT_STATUS bit field.
 * @return The 3-bit value of PACK_CURRENT_STATUS.
 */
uint16_t MP2790::PACK_CURRENT_STATUS() {
    return readBitField(PWR_STATUS, PACK_CURRENT_STATUS_SB, PACK_CURRENT_STATUS_LEN);
}
/**
 * @brief Writes to the PACK_CURRENT_STATUS bit field.
 * @param value The 3-bit value to write.
 */
void MP2790::PACK_CURRENT_STATUS(uint16_t value) {
    throw std::runtime_error("Error: PACK_CURRENT_STATUS is read-only. Cannot write.");
}

/**
 * @brief Reads the PWR_STATE bit field.
 * @return The 5-bit value of PWR_STATE.
 */
uint16_t MP2790::PWR_STATE() {
    return readBitField(PWR_STATUS, PWR_STATE_SB, PWR_STATE_LEN);
}
/**
 * @brief Writes to the PWR_STATE bit field.
 * @param value The 5-bit value to write.
 */
void MP2790::PWR_STATE(uint16_t value) {
    throw std::runtime_error("Error: PWR_STATE is read-only. Cannot write.");
}

// Register: STB_STATUS (0x02) - Access: Read-Only (0)
/**
 * @brief Reads the PACKP_COMP_STS bit field.
 * @return The 3-bit value of PACKP_COMP_STS.
 */
uint16_t MP2790::PACKP_COMP_STS() {
    return readBitField(STB_STATUS, PACKP_COMP_STS_SB, PACKP_COMP_STS_LEN);
}
/**
 * @brief Writes to the PACKP_COMP_STS bit field.
 * @param value The 3-bit value to write.
 */
void MP2790::PACKP_COMP_STS(uint16_t value) {
    throw std::runtime_error("Error: PACKP_COMP_STS is read-only. Cannot write.");
}

/**
 * @brief Reads the DSG_PFET_SYNC bit field.
 * @return The 1-bit value of DSG_PFET_SYNC.
 */
uint16_t MP2790::DSG_PFET_SYNC() {
    return readBitField(STB_STATUS, DSG_PFET_SYNC_SB, DSG_PFET_SYNC_LEN);
}
/**
 * @brief Writes to the DSG_PFET_SYNC bit field.
 * @param value The 1-bit value to write.
 */
void MP2790::DSG_PFET_SYNC(uint16_t value) {
    throw std::runtime_error("Error: DSG_PFET_SYNC is read-only. Cannot write.");
}

/**
 * @brief Reads the STBY_STATE bit field.
 * @return The 1-bit value of STBY_STATE.
 */
uint16_t MP2790::STBY_STATE() {
    return readBitField(STB_STATUS, STBY_STATE_SB, STBY_STATE_LEN);
}
/**
 * @brief Writes to the STBY_STATE bit field.
 * @param value The 1-bit value to write.
 */
void MP2790::STBY_STATE(uint16_t value) {
    throw std::runtime_error("Error: STBY_STATE is read-only. Cannot write.");
}

// Register: LOAD_CHARGER_STATUS (0x03) - Access: Read-Only (0)
/**
 * @brief Reads the CHG_IN bit field.
 * @return The 1-bit value of CHG_IN.
 */
uint16_t MP2790::CHG_IN() {
    return readBitField(LOAD_CHARGER_STATUS, CHG_IN_SB, CHG_IN_LEN);
}
/**
 * @brief Writes to the CHG_IN bit field.
 * @param value The 1-bit value to write.
 */
void MP2790::CHG_IN(uint16_t value) {
    throw std::runtime_error("Error: CHG_IN is read-only. Cannot write.");
}

/**
 * @brief Reads the CHG_EN bit field.
 * @return The 1-bit value of CHG_EN.
 */
uint16_t MP2790::CHG_EN() {
    return readBitField(LOAD_CHARGER_STATUS, CHG_EN_SB, CHG_EN_LEN);
}
/**
 * @brief Writes to the CHG_EN bit field.
 * @param value The 1-bit value to write.
 */
void MP2790::CHG_EN(uint16_t value) {
    throw std::runtime_error("Error: CHG_EN is read-only. Cannot write.");
}

/**
 * @brief Reads the LOAD_EN bit field.
 * @return The 1-bit value of LOAD_EN.
 */
uint16_t MP2790::LOAD_EN() {
    return readBitField(LOAD_CHARGER_STATUS, LOAD_EN_SB, LOAD_EN_LEN);
}
/**
 * @brief Writes to the LOAD_EN bit field.
 * @param value The 1-bit value to write.
 */
void MP2790::LOAD_EN(uint16_t value) {
    throw std::runtime_error("Error: LOAD_EN is read-only. Cannot write.");
}

// Register: ACT_CFG (0x05) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the ACT_MODE bit field.
 * @return The 4-bit value of ACT_MODE.
 */
uint16_t MP2790::ACT_MODE() {
    return readBitField(ACT_CFG, ACT_MODE_SB, ACT_MODE_LEN);
}
/**
 * @brief Writes to the ACT_MODE bit field (MTP capable).
 * @param value The 4-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::ACT_MODE(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for ACT_MODE. Expected MTP mode.");
    }
    writeBitField(ACT_CFG, ACT_MODE_SB, ACT_MODE_LEN, value);
}

// Register: STB_CFG (0x06) - Access: Read/Write (2)
/**
 * @brief Reads the STBY_WAKE bit field.
 * @return The 1-bit value of STBY_WAKE.
 */
uint16_t MP2790::STBY_WAKE() {
    return readBitField(STB_CFG, STBY_WAKE_SB, STBY_WAKE_LEN);
}
/**
 * @brief Writes to the STBY_WAKE bit field.
 * @param value The 1-bit value to write.
 */
void MP2790::STBY_WAKE(uint16_t value) {
    writeBitField(STB_CFG, STBY_WAKE_SB, STBY_WAKE_LEN, value);
}

// Register: SAFE_CFG (0x07) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the SAFE_MODE_CFG bit field.
 * @return The 1-bit value of SAFE_MODE_CFG.
 */
uint16_t MP2790::SAFE_MODE_CFG() {
    return readBitField(SAFE_CFG, SAFE_MODE_CFG_SB, SAFE_MODE_CFG_LEN);
}
/**
 * @brief Writes to the SAFE_MODE_CFG bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::SAFE_MODE_CFG(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for SAFE_MODE_CFG. Expected MTP mode.");
    }
    writeBitField(SAFE_CFG, SAFE_MODE_CFG_SB, SAFE_MODE_CFG_LEN, value);
}

// Register: RGL_CFG (0x08) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the RGL_CFG_EN bit field.
 * @return The 1-bit value of RGL_CFG_EN.
 */
uint16_t MP2790::RGL_CFG_EN() {
    return readBitField(RGL_CFG, RGL_CFG_EN_SB, RGL_CFG_EN_LEN);
}
/**
 * @brief Writes to the RGL_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::RGL_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for RGL_CFG_EN. Expected MTP mode.");
    }
    writeBitField(RGL_CFG, RGL_CFG_EN_SB, RGL_CFG_EN_LEN, value);
}

// Register: LOAD_CHARGER_CFG (0x09) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the LOAD_CFG bit field.
 * @return The 1-bit value of LOAD_CFG.
 */
uint16_t MP2790::LOAD_CFG() {
    return readBitField(LOAD_CHARGER_CFG, LOAD_CFG_SB, LOAD_CFG_LEN);
}
/**
 * @brief Writes to the LOAD_CFG bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::LOAD_CFG(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for LOAD_CFG. Expected MTP mode.");
    }
    writeBitField(LOAD_CHARGER_CFG, LOAD_CFG_SB, LOAD_CFG_LEN, value);
}

/**
 * @brief Reads the CHG_CFG bit field.
 * @return The 1-bit value of CHG_CFG.
 */
uint16_t MP2790::CHG_CFG() {
    return readBitField(LOAD_CHARGER_CFG, CHG_CFG_SB, CHG_CFG_LEN);
}
/**
 * @brief Writes to the CHG_CFG bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CHG_CFG(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CHG_CFG. Expected MTP mode.");
    }
    writeBitField(LOAD_CHARGER_CFG, CHG_CFG_SB, CHG_CFG_LEN, value);
}

// Register: GPIO_STATUS (0x0A) - Access: Write-Only (1)
/**
 * @brief Reads the GPIO_IN_STATUS bit field.
 * @return The 1-bit value of GPIO_IN_STATUS.
 */
uint16_t MP2790::GPIO_IN_STATUS() {
    throw std::runtime_error("Error: GPIO_IN_STATUS is write-only. Cannot read.");
}

// Register: GPIO_OUT (0x0B) - Access: Write-Only (1)
/**
 * @brief Reads the GPIO_OUT_STATUS bit field.
 * @return The 1-bit value of GPIO_OUT_STATUS.
 */
uint16_t MP2790::GPIO_OUT_STATUS() {
    throw std::runtime_error("Error: GPIO_OUT_STATUS is write-only. Cannot read.");
}

// Register: GPIO_CFG (0x0C) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the GPIO_CFG_EN bit field.
 * @return The 1-bit value of GPIO_CFG_EN.
 */
uint16_t MP2790::GPIO_CFG_EN() {
    return readBitField(GPIO_CFG, GPIO_CFG_EN_SB, GPIO_CFG_EN_LEN);
}
/**
 * @brief Writes to the GPIO_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::GPIO_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for GPIO_CFG_EN. Expected MTP mode.");
    }
    writeBitField(GPIO_CFG, GPIO_CFG_EN_SB, GPIO_CFG_EN_LEN, value);
}

// Register: PINS_CFG (0x0D) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the PINS_CFG_EN bit field.
 * @return The 1-bit value of PINS_CFG_EN.
 */
uint16_t MP2790::PINS_CFG_EN() {
    return readBitField(PINS_CFG, PINS_CFG_EN_SB, PINS_CFG_EN_LEN);
}
/**
 * @brief Writes to the PINS_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::PINS_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for PINS_CFG_EN. Expected MTP mode.");
    }
    writeBitField(PINS_CFG, PINS_CFG_EN_SB, PINS_CFG_EN_LEN, value);
}

// Register: WDT_STATUS (0x0E) - Access: Write-Only (1)
/**
 * @brief Reads the WDT_STATUS_EN bit field.
 * @return The 1-bit value of WDT_STATUS_EN.
 */
uint16_t MP2790::WDT_STATUS_EN() {
    throw std::runtime_error("Error: WDT_STATUS_EN is write-only. Cannot read.");
}

// Register: WDT_RST (0x0F) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the WDT_RST_EN bit field.
 * @return The 1-bit value of WDT_RST_EN.
 */
uint16_t MP2790::WDT_RST_EN() {
    return readBitField(WDT_RST, WDT_RST_EN_SB, WDT_RST_EN_LEN);
}
/**
 * @brief Writes to the WDT_RST_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::WDT_RST_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for WDT_RST_EN. Expected MTP mode.");
    }
    writeBitField(WDT_RST, WDT_RST_EN_SB, WDT_RST_EN_LEN, value);
}

// Register: WDT_CFG (0x10) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the WDT_CFG_EN bit field.
 * @return The 1-bit value of WDT_CFG_EN.
 */
uint16_t MP2790::WDT_CFG_EN() {
    return readBitField(WDT_CFG, WDT_CFG_EN_SB, WDT_CFG_EN_LEN);
}
/**
 * @brief Writes to the WDT_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::WDT_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for WDT_CFG_EN. Expected MTP mode.");
    }
    writeBitField(WDT_CFG, WDT_CFG_EN_SB, WDT_CFG_EN_LEN, value);
}

// Register: FET_STATUS (0x11) - Access: Write-Only (1)
/**
 * @brief Reads the FET_STATUS_EN bit field.
 * @return The 1-bit value of FET_STATUS_EN.
 */
uint16_t MP2790::FET_STATUS_EN() {
    throw std::runtime_error("Error: FET_STATUS_EN is write-only. Cannot read.");
}

// Register: FET_CTRL (0x12) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the FET_CTRL_EN bit field.
 * @return The 1-bit value of FET_CTRL_EN.
 */
uint16_t MP2790::FET_CTRL_EN() {
    return readBitField(FET_CTRL, FET_CTRL_EN_SB, FET_CTRL_EN_LEN);
}
/**
 * @brief Writes to the FET_CTRL_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::FET_CTRL_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for FET_CTRL_EN. Expected MTP mode.");
    }
    writeBitField(FET_CTRL, FET_CTRL_EN_SB, FET_CTRL_EN_LEN, value);
}

// Register: FET_MODE (0x13) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the FET_MODE_EN bit field.
 * @return The 1-bit value of FET_MODE_EN.
 */
uint16_t MP2790::FET_MODE_EN() {
    return readBitField(FET_MODE, FET_MODE_EN_SB, FET_MODE_EN_LEN);
}
/**
 * @brief Writes to the FET_MODE_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::FET_MODE_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for FET_MODE_EN. Expected MTP mode.");
    }
    writeBitField(FET_MODE, FET_MODE_EN_SB, FET_MODE_EN_LEN, value);
}

// Register: FET_CFG (0x14) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the FET_CFG_EN bit field.
 * @return The 1-bit value of FET_CFG_EN.
 */
uint16_t MP2790::FET_CFG_EN() {
    return readBitField(FET_CFG, FET_CFG_EN_SB, FET_CFG_EN_LEN);
}
/**
 * @brief Writes to the FET_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::FET_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for FET_CFG_EN. Expected MTP mode.");
    }
    writeBitField(FET_CFG, FET_CFG_EN_SB, FET_CFG_EN_LEN, value);
}

// Register: RD_INT0 (0x15) - Access: Write-Only (1)
/**
 * @brief Reads the RD_INT0_EN bit field.
 * @return The 1-bit value of RD_INT0_EN.
 */
uint16_t MP2790::RD_INT0_EN() {
    throw std::runtime_error("Error: RD_INT0_EN is write-only. Cannot read.");
}

// Register: RD_INT1 (0x16) - Access: Write-Only (1)
/**
 * @brief Reads the RD_INT1_EN bit field.
 * @return The 1-bit value of RD_INT1_EN.
 */
uint16_t MP2790::RD_INT1_EN() {
    throw std::runtime_error("Error: RD_INT1_EN is write-only. Cannot read.");
}

// Register: INT0_CLR (0x17) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the INT0_CLR_EN bit field.
 * @return The 1-bit value of INT0_CLR_EN.
 */
uint16_t MP2790::INT0_CLR_EN() {
    return readBitField(INT0_CLR, INT0_CLR_EN_SB, INT0_CLR_EN_LEN);
}
/**
 * @brief Writes to the INT0_CLR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::INT0_CLR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for INT0_CLR_EN. Expected MTP mode.");
    }
    writeBitField(INT0_CLR, INT0_CLR_EN_SB, INT0_CLR_EN_LEN, value);
}

// Register: INT1_CLR (0x18) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the INT1_CLR_EN bit field.
 * @return The 1-bit value of INT1_CLR_EN.
 */
uint16_t MP2790::INT1_CLR_EN() {
    return readBitField(INT1_CLR, INT1_CLR_EN_SB, INT1_CLR_EN_LEN);
}
/**
 * @brief Writes to the INT1_CLR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::INT1_CLR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for INT1_CLR_EN. Expected MTP mode.");
    }
    writeBitField(INT1_CLR, INT1_CLR_EN_SB, INT1_CLR_EN_LEN, value);
}

// Register: INT0_EN (0x19) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the INT0_EN_EN bit field.
 * @return The 1-bit value of INT0_EN_EN.
 */
uint16_t MP2790::INT0_EN_EN() {
    return readBitField(INT0_EN, INT0_EN_EN_SB, INT0_EN_EN_LEN);
}
/**
 * @brief Writes to the INT0_EN_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::INT0_EN_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for INT0_EN_EN. Expected MTP mode.");
    }
    writeBitField(INT0_EN, INT0_EN_EN_SB, INT0_EN_EN_LEN, value);
}

// Register: INT1_EN (0x1A) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the INT1_EN_EN bit field.
 * @return The 1-bit value of INT1_EN_EN.
 */
uint16_t MP2790::INT1_EN_EN() {
    return readBitField(INT1_EN, INT1_EN_EN_SB, INT1_EN_EN_LEN);
}
/**
 * @brief Writes to the INT1_EN_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::INT1_EN_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for INT1_EN_EN. Expected MTP mode.");
    }
    writeBitField(INT1_EN, INT1_EN_EN_SB, INT1_EN_EN_LEN, value);
}

// Register: INT_TYPE0 (0x1B) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the INT_TYPE0_EN bit field.
 * @return The 1-bit value of INT_TYPE0_EN.
 */
uint16_t MP2790::INT_TYPE0_EN() {
    return readBitField(INT_TYPE0, INT_TYPE0_EN_SB, INT_TYPE0_EN_LEN);
}
/**
 * @brief Writes to the INT_TYPE0_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::INT_TYPE0_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for INT_TYPE0_EN. Expected MTP mode.");
    }
    writeBitField(INT_TYPE0, INT_TYPE0_EN_SB, INT_TYPE0_EN_LEN, value);
}

// Register: INT_TYPE1 (0x1C) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the INT_TYPE1_EN bit field.
 * @return The 1-bit value of INT_TYPE1_EN.
 */
uint16_t MP2790::INT_TYPE1_EN() {
    return readBitField(INT_TYPE1, INT_TYPE1_EN_SB, INT_TYPE1_EN_LEN);
}
/**
 * @brief Writes to the INT_TYPE1_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::INT_TYPE1_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for INT_TYPE1_EN. Expected MTP mode.");
    }
    writeBitField(INT_TYPE1, INT_TYPE1_EN_SB, INT_TYPE1_EN_LEN, value);
}

// Register: INT_TYPE2 (0x1D) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the INT_TYPE2_EN bit field.
 * @return The 1-bit value of INT_TYPE2_EN.
 */
uint16_t MP2790::INT_TYPE2_EN() {
    return readBitField(INT_TYPE2, INT_TYPE2_EN_SB, INT_TYPE2_EN_LEN);
}
/**
 * @brief Writes to the INT_TYPE2_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::INT_TYPE2_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for INT_TYPE2_EN. Expected MTP mode.");
    }
    writeBitField(INT_TYPE2, INT_TYPE2_EN_SB, INT_TYPE2_EN_LEN, value);
}

// Register: MASK_INT0 (0x1E) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the MASK_INT0_EN bit field.
 * @return The 1-bit value of MASK_INT0_EN.
 */
uint16_t MP2790::MASK_INT0_EN() {
    return readBitField(MASK_INT0, MASK_INT0_EN_SB, MASK_INT0_EN_LEN);
}
/**
 * @brief Writes to the MASK_INT0_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::MASK_INT0_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for MASK_INT0_EN. Expected MTP mode.");
    }
    writeBitField(MASK_INT0, MASK_INT0_EN_SB, MASK_INT0_EN_LEN, value);
}

// Register: MASK_INT1 (0x1F) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the MASK_INT1_EN bit field.
 * @return The 1-bit value of MASK_INT1_EN.
 */
uint16_t MP2790::MASK_INT1_EN() {
    return readBitField(MASK_INT1, MASK_INT1_EN_SB, MASK_INT1_EN_LEN);
}
/**
 * @brief Writes to the MASK_INT1_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::MASK_INT1_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for MASK_INT1_EN. Expected MTP mode.");
    }
    writeBitField(MASK_INT1, MASK_INT1_EN_SB, MASK_INT1_EN_LEN, value);
}

// Register: OC_STATUS (0x20) - Access: Write-Only (1)
/**
 * @brief Reads the OC_STATUS_EN bit field.
 * @return The 1-bit value of OC_STATUS_EN.
 */
uint16_t MP2790::OC_STATUS_EN() {
    throw std::runtime_error("Error: OC_STATUS_EN is write-only. Cannot read.");
}

// Register: OCFT_CTRL (0x23) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the OCFT_CTRL_EN bit field.
 * @return The 1-bit value of OCFT_CTRL_EN.
 */
uint16_t MP2790::OCFT_CTRL_EN() {
    return readBitField(OCFT_CTRL, OCFT_CTRL_EN_SB, OCFT_CTRL_EN_LEN);
}
/**
 * @brief Writes to the OCFT_CTRL_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::OCFT_CTRL_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for OCFT_CTRL_EN. Expected MTP mode.");
    }
    writeBitField(OCFT_CTRL, OCFT_CTRL_EN_SB, OCFT_CTRL_EN_LEN, value);
}

// Register: DSGOC_LIM (0x24) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the DSGOC_LIM_EN bit field.
 * @return The 1-bit value of DSGOC_LIM_EN.
 */
uint16_t MP2790::DSGOC_LIM_EN() {
    return readBitField(DSGOC_LIM, DSGOC_LIM_EN_SB, DSGOC_LIM_EN_LEN);
}
/**
 * @brief Writes to the DSGOC_LIM_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::DSGOC_LIM_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for DSGOC_LIM_EN. Expected MTP mode.");
    }
    writeBitField(DSGOC_LIM, DSGOC_LIM_EN_SB, DSGOC_LIM_EN_LEN, value);
}

// Register: DSGOC_DEG (0x25) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the DSGOC_DEG_EN bit field.
 * @return The 1-bit value of DSGOC_DEG_EN.
 */
uint16_t MP2790::DSGOC_DEG_EN() {
    return readBitField(DSGOC_DEG, DSGOC_DEG_EN_SB, DSGOC_DEG_EN_LEN);
}
/**
 * @brief Writes to the DSGOC_DEG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::DSGOC_DEG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for DSGOC_DEG_EN. Expected MTP mode.");
    }
    writeBitField(DSGOC_DEG, DSGOC_DEG_EN_SB, DSGOC_DEG_EN_LEN, value);
}

// Register: CHGOC_DEG (0x26) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CHGOC_DEG_EN bit field.
 * @return The 1-bit value of CHGOC_DEG_EN.
 */
uint16_t MP2790::CHGOC_DEG_EN() {
    return readBitField(CHGOC_DEG, CHGOC_DEG_EN_SB, CHGOC_DEG_EN_LEN);
}
/**
 * @brief Writes to the CHGOC_DEG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CHGOC_DEG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CHGOC_DEG_EN. Expected MTP mode.");
    }
    writeBitField(CHGOC_DEG, CHGOC_DEG_EN_SB, CHGOC_DEG_EN_LEN, value);
}

// Register: SC_STATUS (0x27) - Access: Write-Only (1)
/**
 * @brief Reads the SC_STATUS_EN bit field.
 * @return The 1-bit value of SC_STATUS_EN.
 */
uint16_t MP2790::SC_STATUS_EN() {
    throw std::runtime_error("Error: SC_STATUS_EN is write-only. Cannot read.");
}

// Register: SCFT_CTRL (0x2A) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the SCFT_CTRL_EN bit field.
 * @return The 1-bit value of SCFT_CTRL_EN.
 */
uint16_t MP2790::SCFT_CTRL_EN() {
    return readBitField(SCFT_CTRL, SCFT_CTRL_EN_SB, SCFT_CTRL_EN_LEN);
}
/**
 * @brief Writes to the SCFT_CTRL_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::SCFT_CTRL_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for SCFT_CTRL_EN. Expected MTP mode.");
    }
    writeBitField(SCFT_CTRL, SCFT_CTRL_EN_SB, SCFT_CTRL_EN_LEN, value);
}

// Register: DSGSC_CFG (0x2B) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the DSGSC_CFG_EN bit field.
 * @return The 1-bit value of DSGSC_CFG_EN.
 */
uint16_t MP2790::DSGSC_CFG_EN() {
    return readBitField(DSGSC_CFG, DSGSC_CFG_EN_SB, DSGSC_CFG_EN_LEN);
}
/**
 * @brief Writes to the DSGSC_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::DSGSC_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for DSGSC_CFG_EN. Expected MTP mode.");
    }
    writeBitField(DSGSC_CFG, DSGSC_CFG_EN_SB, DSGSC_CFG_EN_LEN, value);
}

// Register: CHGSC_CFG (0x2C) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CHGSC_CFG_EN bit field.
 * @return The 1-bit value of CHGSC_CFG_EN.
 */
uint16_t MP2790::CHGSC_CFG_EN() {
    return readBitField(CHGSC_CFG, CHGSC_CFG_EN_SB, CHGSC_CFG_EN_LEN);
}
/**
 * @brief Writes to the CHGSC_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CHGSC_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CHGSC_CFG_EN. Expected MTP mode.");
    }
    writeBitField(CHGSC_CFG, CHGSC_CFG_EN_SB, CHGSC_CFG_EN_LEN, value);
}

// Register: RD_CELL_UV (0x2D) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CELL_UV_EN bit field.
 * @return The 1-bit value of RD_CELL_UV_EN.
 */
uint16_t MP2790::RD_CELL_UV_EN() {
    throw std::runtime_error("Error: RD_CELL_UV_EN is write-only. Cannot read.");
}

// Register: RD_CELL_OV (0x2E) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CELL_OV_EN bit field.
 * @return The 1-bit value of RD_CELL_OV_EN.
 */
uint16_t MP2790::RD_CELL_OV_EN() {
    throw std::runtime_error("Error: RD_CELL_OV_EN is write-only. Cannot read.");
}

// Register: RD_CELL_MSMT (0x2F) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CELL_MSMT_EN bit field.
 * @return The 1-bit value of RD_CELL_MSMT_EN.
 */
uint16_t MP2790::RD_CELL_MSMT_EN() {
    throw std::runtime_error("Error: RD_CELL_MSMT_EN is write-only. Cannot read.");
}

// Register: RD_CELL_DEAD (0x30) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CELL_DEAD_EN bit field.
 * @return The 1-bit value of RD_CELL_DEAD_EN.
 */
uint16_t MP2790::RD_CELL_DEAD_EN() {
    throw std::runtime_error("Error: RD_CELL_DEAD_EN is write-only. Cannot read.");
}

// Register: CELL_MSMT_STS (0x33) - Access: Write-Only (1)
/**
 * @brief Reads the CELL_MSMT_STS_EN bit field.
 * @return The 1-bit value of CELL_MSMT_STS_EN.
 */
uint16_t MP2790::CELL_MSMT_STS_EN() {
    throw std::runtime_error("Error: CELL_MSMT_STS_EN is write-only. Cannot read.");
}

// Register: PACKFT_CTRL (0x34) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the PACKFT_CTRL_EN bit field.
 * @return The 1-bit value of PACKFT_CTRL_EN.
 */
uint16_t MP2790::PACKFT_CTRL_EN() {
    return readBitField(PACKFT_CTRL, PACKFT_CTRL_EN_SB, PACKFT_CTRL_EN_LEN);
}
/**
 * @brief Writes to the PACKFT_CTRL_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::PACKFT_CTRL_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for PACKFT_CTRL_EN. Expected MTP mode.");
    }
    writeBitField(PACKFT_CTRL, PACKFT_CTRL_EN_SB, PACKFT_CTRL_EN_LEN, value);
}

// Register: CELLFT_CTRL (0x35) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CELLFT_CTRL_EN bit field.
 * @return The 1-bit value of CELLFT_CTRL_EN.
 */
uint16_t MP2790::CELLFT_CTRL_EN() {
    return readBitField(CELLFT_CTRL, CELLFT_CTRL_EN_SB, CELLFT_CTRL_EN_LEN);
}
/**
 * @brief Writes to the CELLFT_CTRL_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CELLFT_CTRL_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CELLFT_CTRL_EN. Expected MTP mode.");
    }
    writeBitField(CELLFT_CTRL, CELLFT_CTRL_EN_SB, CELLFT_CTRL_EN_LEN, value);
}

// Register: CELL_HYST (0x36) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CELL_HYST_EN bit field.
 * @return The 1-bit value of CELL_HYST_EN.
 */
uint16_t MP2790::CELL_HYST_EN() {
    return readBitField(CELL_HYST, CELL_HYST_EN_SB, CELL_HYST_EN_LEN);
}
/**
 * @brief Writes to the CELL_HYST_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CELL_HYST_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CELL_HYST_EN. Expected MTP mode.");
    }
    writeBitField(CELL_HYST, CELL_HYST_EN_SB, CELL_HYST_EN_LEN, value);
}

// Register: PACK_UV_OV (0x37) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the PACK_UV_OV_EN bit field.
 * @return The 1-bit value of PACK_UV_OV_EN.
 */
uint16_t MP2790::PACK_UV_OV_EN() {
    return readBitField(PACK_UV_OV, PACK_UV_OV_EN_SB, PACK_UV_OV_EN_LEN);
}
/**
 * @brief Writes to the PACK_UV_OV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::PACK_UV_OV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for PACK_UV_OV_EN. Expected MTP mode.");
    }
    writeBitField(PACK_UV_OV, PACK_UV_OV_EN_SB, PACK_UV_OV_EN_LEN, value);
}

// Register: CELL_UV (0x38) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CELL_UV_EN bit field.
 * @return The 1-bit value of CELL_UV_EN.
 */
uint16_t MP2790::CELL_UV_EN() {
    return readBitField(CELL_UV, CELL_UV_EN_SB, CELL_UV_EN_LEN);
}
/**
 * @brief Writes to the CELL_UV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CELL_UV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CELL_UV_EN. Expected MTP mode.");
    }
    writeBitField(CELL_UV, CELL_UV_EN_SB, CELL_UV_EN_LEN, value);
}

// Register: CELL_OV (0x39) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CELL_OV_EN bit field.
 * @return The 1-bit value of CELL_OV_EN.
 */
uint16_t MP2790::CELL_OV_EN() {
    return readBitField(CELL_OV, CELL_OV_EN_SB, CELL_OV_EN_LEN);
}
/**
 * @brief Writes to the CELL_OV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CELL_OV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CELL_OV_EN. Expected MTP mode.");
    }
    writeBitField(CELL_OV, CELL_OV_EN_SB, CELL_OV_EN_LEN, value);
}

// Register: PACK_UV (0x3A) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the PACK_UV_EN bit field.
 * @return The 1-bit value of PACK_UV_EN.
 */
uint16_t MP2790::PACK_UV_EN() {
    return readBitField(PACK_UV, PACK_UV_EN_SB, PACK_UV_EN_LEN);
}
/**
 * @brief Writes to the PACK_UV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::PACK_UV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for PACK_UV_EN. Expected MTP mode.");
    }
    writeBitField(PACK_UV, PACK_UV_EN_SB, PACK_UV_EN_LEN, value);
}

// Register: PACK_OV (0x3B) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the PACK_OV_EN bit field.
 * @return The 1-bit value of PACK_OV_EN.
 */
uint16_t MP2790::PACK_OV_EN() {
    return readBitField(PACK_OV, PACK_OV_EN_SB, PACK_OV_EN_LEN);
}
/**
 * @brief Writes to the PACK_OV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::PACK_OV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for PACK_OV_EN. Expected MTP mode.");
    }
    writeBitField(PACK_OV, PACK_OV_EN_SB, PACK_OV_EN_LEN, value);
}

// Register: CELL_DEAD_THR (0x3C) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CELL_DEAD_THR_EN bit field.
 * @return The 1-bit value of CELL_DEAD_THR_EN.
 */
uint16_t MP2790::CELL_DEAD_THR_EN() {
    return readBitField(CELL_DEAD_THR, CELL_DEAD_THR_EN_SB, CELL_DEAD_THR_EN_LEN);
}
/**
 * @brief Writes to the CELL_DEAD_THR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CELL_DEAD_THR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CELL_DEAD_THR_EN. Expected MTP mode.");
    }
    writeBitField(CELL_DEAD_THR, CELL_DEAD_THR_EN_SB, CELL_DEAD_THR_EN_LEN, value);
}

// Register: CELL_MSMT (0x3D) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CELL_MSMT_EN bit field.
 * @return The 1-bit value of CELL_MSMT_EN.
 */
uint16_t MP2790::CELL_MSMT_EN() {
    return readBitField(CELL_MSMT, CELL_MSMT_EN_SB, CELL_MSMT_EN_LEN);
}
/**
 * @brief Writes to the CELL_MSMT_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CELL_MSMT_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CELL_MSMT_EN. Expected MTP mode.");
    }
    writeBitField(CELL_MSMT, CELL_MSMT_EN_SB, CELL_MSMT_EN_LEN, value);
}

// Register: RD_NTC_DIE (0x3E) - Access: Write-Only (1)
/**
 * @brief Reads the RD_NTC_DIE_EN bit field.
 * @return The 1-bit value of RD_NTC_DIE_EN.
 */
uint16_t MP2790::RD_NTC_DIE_EN() {
    throw std::runtime_error("Error: RD_NTC_DIE_EN is write-only. Cannot read.");
}

// Register: RD_V_NTC4_LR (0x3F) - Access: Write-Only (1)
/**
 * @brief Reads the RD_V_NTC4_LR_EN bit field.
 * @return The 1-bit value of RD_V_NTC4_LR_EN.
 */
uint16_t MP2790::RD_V_NTC4_LR_EN() {
    throw std::runtime_error("Error: RD_V_NTC4_LR_EN is write-only. Cannot read.");
}

// Register: RD_VNTC3_LR (0x40) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VNTC3_LR_EN bit field.
 * @return The 1-bit value of RD_VNTC3_LR_EN.
 */
uint16_t MP2790::RD_VNTC3_LR_EN() {
    throw std::runtime_error("Error: RD_VNTC3_LR_EN is write-only. Cannot read.");
}

// Register: RD_V_NTC2_LR (0x41) - Access: Write-Only (1)
/**
 * @brief Reads the RD_V_NTC2_LR_EN bit field.
 * @return The 1-bit value of RD_V_NTC2_LR_EN.
 */
uint16_t MP2790::RD_V_NTC2_LR_EN() {
    throw std::runtime_error("Error: RD_V_NTC2_LR_EN is write-only. Cannot read.");
}

// Register: RD_V_NTC1_LR (0x42) - Access: Write-Only (1)
/**
 * @brief Reads the RD_V_NTC1_LR_EN bit field.
 * @return The 1-bit value of RD_V_NTC1_LR_EN.
 */
uint16_t MP2790::RD_V_NTC1_LR_EN() {
    throw std::runtime_error("Error: RD_V_NTC1_LR_EN is write-only. Cannot read.");
}

// Register: RD_T_DIE (0x43) - Access: Write-Only (1)
/**
 * @brief Reads the RD_T_DIE_EN bit field.
 * @return The 1-bit value of RD_T_DIE_EN.
 */
uint16_t MP2790::RD_T_DIE_EN() {
    throw std::runtime_error("Error: RD_T_DIE_EN is write-only. Cannot read.");
}

// Register: W_NTC_CLR (0x44) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the W_NTC_CLR_EN bit field.
 * @return The 1-bit value of W_NTC_CLR_EN.
 */
uint16_t MP2790::W_NTC_CLR_EN() {
    return readBitField(W_NTC_CLR, W_NTC_CLR_EN_SB, W_NTC_CLR_EN_LEN);
}
/**
 * @brief Writes to the W_NTC_CLR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::W_NTC_CLR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for W_NTC_CLR_EN. Expected MTP mode.");
    }
    writeBitField(W_NTC_CLR, W_NTC_CLR_EN_SB, W_NTC_CLR_EN_LEN, value);
}

// Register: DIE_CFG (0x46) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the DIE_CFG_EN bit field.
 * @return The 1-bit value of DIE_CFG_EN.
 */
uint16_t MP2790::DIE_CFG_EN() {
    return readBitField(DIE_CFG, DIE_CFG_EN_SB, DIE_CFG_EN_LEN);
}
/**
 * @brief Writes to the DIE_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::DIE_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for DIE_CFG_EN. Expected MTP mode.");
    }
    writeBitField(DIE_CFG, DIE_CFG_EN_SB, DIE_CFG_EN_LEN, value);
}

// Register: NTC_CFG (0x47) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the NTC_CFG_EN bit field.
 * @return The 1-bit value of NTC_CFG_EN.
 */
uint16_t MP2790::NTC_CFG_EN() {
    return readBitField(NTC_CFG, NTC_CFG_EN_SB, NTC_CFG_EN_LEN);
}
/**
 * @brief Writes to the NTC_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::NTC_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for NTC_CFG_EN. Expected MTP mode.");
    }
    writeBitField(NTC_CFG, NTC_CFG_EN_SB, NTC_CFG_EN_LEN, value);
}

// Register: NTCC_OTHR_DSG (0x48) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the NTCC_OTHR_DSG_EN bit field.
 * @return The 1-bit value of NTCC_OTHR_DSG_EN.
 */
uint16_t MP2790::NTCC_OTHR_DSG_EN() {
    return readBitField(NTCC_OTHR_DSG, NTCC_OTHR_DSG_EN_SB, NTCC_OTHR_DSG_EN_LEN);
}
/**
 * @brief Writes to the NTCC_OTHR_DSG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::NTCC_OTHR_DSG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for NTCC_OTHR_DSG_EN. Expected MTP mode.");
    }
    writeBitField(NTCC_OTHR_DSG, NTCC_OTHR_DSG_EN_SB, NTCC_OTHR_DSG_EN_LEN, value);
}

// Register: NTCC_UTHR_DSG (0x49) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the NTCC_UTHR_DSG_EN bit field.
 * @return The 1-bit value of NTCC_UTHR_DSG_EN.
 */
uint16_t MP2790::NTCC_UTHR_DSG_EN() {
    return readBitField(NTCC_UTHR_DSG, NTCC_UTHR_DSG_EN_SB, NTCC_UTHR_DSG_EN_LEN);
}
/**
 * @brief Writes to the NTCC_UTHR_DSG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::NTCC_UTHR_DSG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for NTCC_UTHR_DSG_EN. Expected MTP mode.");
    }
    writeBitField(NTCC_UTHR_DSG, NTCC_UTHR_DSG_EN_SB, NTCC_UTHR_DSG_EN_LEN, value);
}

// Register: NTCC_OTHR_CHG (0x4A) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the NTCC_OTHR_CHG_EN bit field.
 * @return The 1-bit value of NTCC_OTHR_CHG_EN.
 */
uint16_t MP2790::NTCC_OTHR_CHG_EN() {
    return readBitField(NTCC_OTHR_CHG, NTCC_OTHR_CHG_EN_SB, NTCC_OTHR_CHG_EN_LEN);
}
/**
 * @brief Writes to the NTCC_OTHR_CHG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::NTCC_OTHR_CHG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for NTCC_OTHR_CHG_EN. Expected MTP mode.");
    }
    writeBitField(NTCC_OTHR_CHG, NTCC_OTHR_CHG_EN_SB, NTCC_OTHR_CHG_EN_LEN, value);
}

// Register: NTCC_UTHR_CHG (0x4B) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the NTCC_UTHR_CHG_EN bit field.
 * @return The 1-bit value of NTCC_UTHR_CHG_EN.
 */
uint16_t MP2790::NTCC_UTHR_CHG_EN() {
    return readBitField(NTCC_UTHR_CHG, NTCC_UTHR_CHG_EN_SB, NTCC_UTHR_CHG_EN_LEN);
}
/**
 * @brief Writes to the NTCC_UTHR_CHG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::NTCC_UTHR_CHG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for NTCC_UTHR_CHG_EN. Expected MTP mode.");
    }
    writeBitField(NTCC_UTHR_CHG, NTCC_UTHR_CHG_EN_SB, NTCC_UTHR_CHG_EN_LEN, value);
}

// Register: NTCM_OTHR (0x4C) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the NTCM_OTHR_EN bit field.
 * @return The 1-bit value of NTCM_OTHR_EN.
 */
uint16_t MP2790::NTCM_OTHR_EN() {
    return readBitField(NTCM_OTHR, NTCM_OTHR_EN_SB, NTCM_OTHR_EN_LEN);
}
/**
 * @brief Writes to the NTCM_OTHR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::NTCM_OTHR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for NTCM_OTHR_EN. Expected MTP mode.");
    }
    writeBitField(NTCM_OTHR, NTCM_OTHR_EN_SB, NTCM_OTHR_EN_LEN, value);
}

// Register: DIE_OT (0x4D) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the DIE_OT_EN bit field.
 * @return The 1-bit value of DIE_OT_EN.
 */
uint16_t MP2790::DIE_OT_EN() {
    return readBitField(DIE_OT, DIE_OT_EN_SB, DIE_OT_EN_LEN);
}
/**
 * @brief Writes to the DIE_OT_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::DIE_OT_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for DIE_OT_EN. Expected MTP mode.");
    }
    writeBitField(DIE_OT, DIE_OT_EN_SB, DIE_OT_EN_LEN, value);
}

// Register: SELF_STS (0x4E) - Access: Write-Only (1)
/**
 * @brief Reads the SELF_STS_EN bit field.
 * @return The 1-bit value of SELF_STS_EN.
 */
uint16_t MP2790::SELF_STS_EN() {
    throw std::runtime_error("Error: SELF_STS_EN is write-only. Cannot read.");
}

// Register: RD_VA1P8 (0x4F) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VA1P8_EN bit field.
 * @return The 1-bit value of RD_VA1P8_EN.
 */
uint16_t MP2790::RD_VA1P8_EN() {
    throw std::runtime_error("Error: RD_VA1P8_EN is write-only. Cannot read.");
}

// Register: RD_VA3P3 (0x50) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VA3P3_EN bit field.
 * @return The 1-bit value of RD_VA3P3_EN.
 */
uint16_t MP2790::RD_VA3P3_EN() {
    throw std::runtime_error("Error: RD_VA3P3_EN is write-only. Cannot read.");
}

// Register: RD_VA5 (0x51) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VA5_EN bit field.
 * @return The 1-bit value of RD_VA5_EN.
 */
uint16_t MP2790::RD_VA5_EN() {
    throw std::runtime_error("Error: RD_VA5_EN is write-only. Cannot read.");
}

// Register: RD_VASELF (0x52) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VASELF_EN bit field.
 * @return The 1-bit value of RD_VASELF_EN.
 */
uint16_t MP2790::RD_VASELF_EN() {
    throw std::runtime_error("Error: RD_VASELF_EN is write-only. Cannot read.");
}

// Register: RD_OPENH (0x53) - Access: Write-Only (1)
/**
 * @brief Reads the RD_OPENH_EN bit field.
 * @return The 1-bit value of RD_OPENH_EN.
 */
uint16_t MP2790::RD_OPENH_EN() {
    throw std::runtime_error("Error: RD_OPENH_EN is write-only. Cannot read.");
}

// Register: SFT_GO (0x55) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the SFT_GO_EN bit field.
 * @return The 1-bit value of SFT_GO_EN.
 */
uint16_t MP2790::SFT_GO_EN() {
    return readBitField(SFT_GO, SFT_GO_EN_SB, SFT_GO_EN_LEN);
}
/**
 * @brief Writes to the SFT_GO_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::SFT_GO_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for SFT_GO_EN. Expected MTP mode.");
    }
    writeBitField(SFT_GO, SFT_GO_EN_SB, SFT_GO_EN_LEN, value);
}

// Register: SELF_CFG (0x56) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the SELF_CFG_EN bit field.
 * @return The 1-bit value of SELF_CFG_EN.
 */
uint16_t MP2790::SELF_CFG_EN() {
    return readBitField(SELF_CFG, SELF_CFG_EN_SB, SELF_CFG_EN_LEN);
}
/**
 * @brief Writes to the SELF_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::SELF_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for SELF_CFG_EN. Expected MTP mode.");
    }
    writeBitField(SELF_CFG, SELF_CFG_EN_SB, SELF_CFG_EN_LEN, value);
}

// Register: OPEN_CFG (0x57) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the OPEN_CFG_EN bit field.
 * @return The 1-bit value of OPEN_CFG_EN.
 */
uint16_t MP2790::OPEN_CFG_EN() {
    return readBitField(OPEN_CFG, OPEN_CFG_EN_SB, OPEN_CFG_EN_LEN);
}
/**
 * @brief Writes to the OPEN_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::OPEN_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for OPEN_CFG_EN. Expected MTP mode.");
    }
    writeBitField(OPEN_CFG, OPEN_CFG_EN_SB, OPEN_CFG_EN_LEN, value);
}

// Register: REGIN_UV (0x58) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the REGIN_UV_EN bit field.
 * @return The 1-bit value of REGIN_UV_EN.
 */
uint16_t MP2790::REGIN_UV_EN() {
    return readBitField(REGIN_UV, REGIN_UV_EN_SB, REGIN_UV_EN_LEN);
}
/**
 * @brief Writes to the REGIN_UV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::REGIN_UV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for REGIN_UV_EN. Expected MTP mode.");
    }
    writeBitField(REGIN_UV, REGIN_UV_EN_SB, REGIN_UV_EN_LEN, value);
}

// Register: V3P3_UV (0x59) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the V3P3_UV_EN bit field.
 * @return The 1-bit value of V3P3_UV_EN.
 */
uint16_t MP2790::V3P3_UV_EN() {
    return readBitField(V3P3_UV, V3P3_UV_EN_SB, V3P3_UV_EN_LEN);
}
/**
 * @brief Writes to the V3P3_UV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::V3P3_UV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for V3P3_UV_EN. Expected MTP mode.");
    }
    writeBitField(V3P3_UV, V3P3_UV_EN_SB, V3P3_UV_EN_LEN, value);
}

// Register: VDD_UV (0x5A) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the VDD_UV_EN bit field.
 * @return The 1-bit value of VDD_UV_EN.
 */
uint16_t MP2790::VDD_UV_EN() {
    return readBitField(VDD_UV, VDD_UV_EN_SB, VDD_UV_EN_LEN);
}
/**
 * @brief Writes to the VDD_UV_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::VDD_UV_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for VDD_UV_EN. Expected MTP mode.");
    }
    writeBitField(VDD_UV, VDD_UV_EN_SB, VDD_UV_EN_LEN, value);
}

// Register: SELF_THR (0x5B) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the SELF_THR_EN bit field.
 * @return The 1-bit value of SELF_THR_EN.
 */
uint16_t MP2790::SELF_THR_EN() {
    return readBitField(SELF_THR, SELF_THR_EN_SB, SELF_THR_EN_LEN);
}
/**
 * @brief Writes to the SELF_THR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::SELF_THR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for SELF_THR_EN. Expected MTP mode.");
    }
    writeBitField(SELF_THR, SELF_THR_EN_SB, SELF_THR_EN_LEN, value);
}

// Register: FT_STS1 (0x5D) - Access: Write-Only (1)
/**
 * @brief Reads the FT_STS1_EN bit field.
 * @return The 1-bit value of FT_STS1_EN.
 */
uint16_t MP2790::FT_STS1_EN() {
    throw std::runtime_error("Error: FT_STS1_EN is write-only. Cannot read.");
}

// Register: FT_STS2 (0x5E) - Access: Write-Only (1)
/**
 * @brief Reads the FT_STS2_EN bit field.
 * @return The 1-bit value of FT_STS2_EN.
 */
uint16_t MP2790::FT_STS2_EN() {
    throw std::runtime_error("Error: FT_STS2_EN is write-only. Cannot read.");
}

// Register: FT_CLR (0x5F) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the FT_CLR_EN bit field.
 * @return The 1-bit value of FT_CLR_EN.
 */
uint16_t MP2790::FT_CLR_EN() {
    return readBitField(FT_CLR, FT_CLR_EN_SB, FT_CLR_EN_LEN);
}
/**
 * @brief Writes to the FT_CLR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::FT_CLR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for FT_CLR_EN. Expected MTP mode.");
    }
    writeBitField(FT_CLR, FT_CLR_EN_SB, FT_CLR_EN_LEN, value);
}

// Register: FT_REC (0x60) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the FT_REC_EN bit field.
 * @return The 1-bit value of FT_REC_EN.
 */
uint16_t MP2790::FT_REC_EN() {
    return readBitField(FT_REC, FT_REC_EN_SB, FT_REC_EN_LEN);
}
/**
 * @brief Writes to the FT_REC_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::FT_REC_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for FT_REC_EN. Expected MTP mode.");
    }
    writeBitField(FT_REC, FT_REC_EN_SB, FT_REC_EN_LEN, value);
}

// Register: FTO_CFG (0x61) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the FTO_CFG_EN bit field.
 * @return The 1-bit value of FTO_CFG_EN.
 */
uint16_t MP2790::FTO_CFG_EN() {
    return readBitField(FTO_CFG, FTO_CFG_EN_SB, FTO_CFG_EN_LEN);
}
/**
 * @brief Writes to the FTO_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::FTO_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for FTO_CFG_EN. Expected MTP mode.");
    }
    writeBitField(FTO_CFG, FTO_CFG_EN_SB, FTO_CFG_EN_LEN, value);
}

// Register: FT1_CFG (0x62) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the FT1_CFG_EN bit field.
 * @return The 1-bit value of FT1_CFG_EN.
 */
uint16_t MP2790::FT1_CFG_EN() {
    return readBitField(FT1_CFG, FT1_CFG_EN_SB, FT1_CFG_EN_LEN);
}
/**
 * @brief Writes to the FT1_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::FT1_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for FT1_CFG_EN. Expected MTP mode.");
    }
    writeBitField(FT1_CFG, FT1_CFG_EN_SB, FT1_CFG_EN_LEN, value);
}

// Register: RD_CCIRQL (0x65) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CCIRQL_EN bit field.
 * @return The 1-bit value of RD_CCIRQL_EN.
 */
uint16_t MP2790::RD_CCIRQL_EN() {
    throw std::runtime_error("Error: RD_CCIRQL_EN is write-only. Cannot read.");
}

// Register: RD_CCIRQH (0x66) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CCIRQH_EN bit field.
 * @return The 1-bit value of RD_CCIRQH_EN.
 */
uint16_t MP2790::RD_CCIRQH_EN() {
    throw std::runtime_error("Error: RD_CCIRQH_EN is write-only. Cannot read.");
}

// Register: RD_CCACCQL (0x67) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CCACCQL_EN bit field.
 * @return The 1-bit value of RD_CCACCQL_EN.
 */
uint16_t MP2790::RD_CCACCQL_EN() {
    throw std::runtime_error("Error: RD_CCACCQL_EN is write-only. Cannot read.");
}

// Register: RD_CCACCQH (0x68) - Access: Write-Only (1)
/**
 * @brief Reads the RD_CCACCQH_EN bit field.
 * @return The 1-bit value of RD_CCACCQH_EN.
 */
uint16_t MP2790::RD_CCACCQH_EN() {
    throw std::runtime_error("Error: RD_CCACCQH_EN is write-only. Cannot read.");
}

// Register: RD_VPACKP (0x69) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VPACKP_EN bit field.
 * @return The 1-bit value of RD_VPACKP_EN.
 */
uint16_t MP2790::RD_VPACKP_EN() {
    throw std::runtime_error("Error: RD_VPACKP_EN is write-only. Cannot read.");
}

// Register: RD_VTOP (0x6A) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VTOP_EN bit field.
 * @return The 1-bit value of RD_VTOP_EN.
 */
uint16_t MP2790::RD_VTOP_EN() {
    throw std::runtime_error("Error: RD_VTOP_EN is write-only. Cannot read.");
}

// Register: RD_ITOP (0x6B) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ITOP_EN bit field.
 * @return The 1-bit value of RD_ITOP_EN.
 */
uint16_t MP2790::RD_ITOP_EN() {
    throw std::runtime_error("Error: RD_ITOP_EN is write-only. Cannot read.");
}

// Register: RD_VCELL1 (0x6C) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL1_EN bit field.
 * @return The 1-bit value of RD_VCELL1_EN.
 */
uint16_t MP2790::RD_VCELL1_EN() {
    throw std::runtime_error("Error: RD_VCELL1_EN is write-only. Cannot read.");
}

// Register: RD_ICELL1 (0x6D) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL1_EN bit field.
 * @return The 1-bit value of RD_ICELL1_EN.
 */
uint16_t MP2790::RD_ICELL1_EN() {
    throw std::runtime_error("Error: RD_ICELL1_EN is write-only. Cannot read.");
}

// Register: RD_VCELL2 (0x6E) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL2_EN bit field.
 * @return The 1-bit value of RD_VCELL2_EN.
 */
uint16_t MP2790::RD_VCELL2_EN() {
    throw std::runtime_error("Error: RD_VCELL2_EN is write-only. Cannot read.");
}

// Register: RD_ICELL2 (0x6F) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL2_EN bit field.
 * @return The 1-bit value of RD_ICELL2_EN.
 */
uint16_t MP2790::RD_ICELL2_EN() {
    throw std::runtime_error("Error: RD_ICELL2_EN is write-only. Cannot read.");
}

// Register: RD_VCELL3 (0x70) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL3_EN bit field.
 * @return The 1-bit value of RD_VCELL3_EN.
 */
uint16_t MP2790::RD_VCELL3_EN() {
    throw std::runtime_error("Error: RD_VCELL3_EN is write-only. Cannot read.");
}

// Register: RD_ICELL3 (0x71) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL3_EN bit field.
 * @return The 1-bit value of RD_ICELL3_EN.
 */
uint16_t MP2790::RD_ICELL3_EN() {
    throw std::runtime_error("Error: RD_ICELL3_EN is write-only. Cannot read.");
}

// Register: RD_VCELL4 (0x72) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL4_EN bit field.
 * @return The 1-bit value of RD_VCELL4_EN.
 */
uint16_t MP2790::RD_VCELL4_EN() {
    throw std::runtime_error("Error: RD_VCELL4_EN is write-only. Cannot read.");
}

// Register: RD_ICELL4 (0x73) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL4_EN bit field.
 * @return The 1-bit value of RD_ICELL4_EN.
 */
uint16_t MP2790::RD_ICELL4_EN() {
    throw std::runtime_error("Error: RD_ICELL4_EN is write-only. Cannot read.");
}

// Register: RD_VCELL5 (0x74) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL5_EN bit field.
 * @return The 1-bit value of RD_VCELL5_EN.
 */
uint16_t MP2790::RD_VCELL5_EN() {
    throw std::runtime_error("Error: RD_VCELL5_EN is write-only. Cannot read.");
}

// Register: RD_ICELL5 (0x75) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL5_EN bit field.
 * @return The 1-bit value of RD_ICELL5_EN.
 */
uint16_t MP2790::RD_ICELL5_EN() {
    throw std::runtime_error("Error: RD_ICELL5_EN is write-only. Cannot read.");
}

// Register: RD_VCELL6 (0x76) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL6_EN bit field.
 * @return The 1-bit value of RD_VCELL6_EN.
 */
uint16_t MP2790::RD_VCELL6_EN() {
    throw std::runtime_error("Error: RD_VCELL6_EN is write-only. Cannot read.");
}

// Register: RD_ICELL6 (0x77) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL6_EN bit field.
 * @return The 1-bit value of RD_ICELL6_EN.
 */
uint16_t MP2790::RD_ICELL6_EN() {
    throw std::runtime_error("Error: RD_ICELL6_EN is write-only. Cannot read.");
}

// Register: RD_VCELL7 (0x78) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL7_EN bit field.
 * @return The 1-bit value of RD_VCELL7_EN.
 */
uint16_t MP2790::RD_VCELL7_EN() {
    throw std::runtime_error("Error: RD_VCELL7_EN is write-only. Cannot read.");
}

// Register: RD_ICELL7 (0x79) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL7_EN bit field.
 * @return The 1-bit value of RD_ICELL7_EN.
 */
uint16_t MP2790::RD_ICELL7_EN() {
    throw std::runtime_error("Error: RD_ICELL7_EN is write-only. Cannot read.");
}

// Register: RD_VCELL8 (0x7A) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL8_EN bit field.
 * @return The 1-bit value of RD_VCELL8_EN.
 */
uint16_t MP2790::RD_VCELL8_EN() {
    throw std::runtime_error("Error: RD_VCELL8_EN is write-only. Cannot read.");
}

// Register: RD_ICELL8 (0x7B) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL8_EN bit field.
 * @return The 1-bit value of RD_ICELL8_EN.
 */
uint16_t MP2790::RD_ICELL8_EN() {
    throw std::runtime_error("Error: RD_ICELL8_EN is write-only. Cannot read.");
}

// Register: RD_VCELL9 (0x7C) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL9_EN bit field.
 * @return The 1-bit value of RD_VCELL9_EN.
 */
uint16_t MP2790::RD_VCELL9_EN() {
    throw std::runtime_error("Error: RD_VCELL9_EN is write-only. Cannot read.");
}

// Register: RD_ICELL9 (0x7D) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL9_EN bit field.
 * @return The 1-bit value of RD_ICELL9_EN.
 */
uint16_t MP2790::RD_ICELL9_EN() {
    throw std::runtime_error("Error: RD_ICELL9_EN is write-only. Cannot read.");
}

// Register: RD_VCELL10 (0x7E) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VCELL10_EN bit field.
 * @return The 1-bit value of RD_VCELL10_EN.
 */
uint16_t MP2790::RD_VCELL10_EN() {
    throw std::runtime_error("Error: RD_VCELL10_EN is write-only. Cannot read.");
}

// Register: RD_ICELL10 (0x7F) - Access: Write-Only (1)
/**
 * @brief Reads the RD_ICELL10_EN bit field.
 * @return The 1-bit value of RD_ICELL10_EN.
 */
uint16_t MP2790::RD_ICELL10_EN() {
    throw std::runtime_error("Error: RD_ICELL10_EN is write-only. Cannot read.");
}

// Register: RD_VNTC4 (0x8C) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VNTC4_EN bit field.
 * @return The 1-bit value of RD_VNTC4_EN.
 */
uint16_t MP2790::RD_VNTC4_EN() {
    throw std::runtime_error("Error: RD_VNTC4_EN is write-only. Cannot read.");
}

// Register: RD_VNTC3 (0x8D) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VNTC3_EN bit field.
 * @return The 1-bit value of RD_VNTC3_EN.
 */
uint16_t MP2790::RD_VNTC3_EN() {
    throw std::runtime_error("Error: RD_VNTC3_EN is write-only. Cannot read.");
}

// Register: RD_VNTC2 (0x8E) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VNTC2_EN bit field.
 * @return The 1-bit value of RD_VNTC2_EN.
 */
uint16_t MP2790::RD_VNTC2_EN() {
    throw std::runtime_error("Error: RD_VNTC2_EN is write-only. Cannot read.");
}

// Register: RD_VNTC1 (0x8F) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VNTC1_EN bit field.
 * @return The 1-bit value of RD_VNTC1_EN.
 */
uint16_t MP2790::RD_VNTC1_EN() {
    throw std::runtime_error("Error: RD_VNTC1_EN is write-only. Cannot read.");
}

// Register: RD_VGPIO3 (0x90) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VGPIO3_EN bit field.
 * @return The 1-bit value of RD_VGPIO3_EN.
 */
uint16_t MP2790::RD_VGPIO3_EN() {
    throw std::runtime_error("Error: RD_VGPIO3_EN is write-only. Cannot read.");
}

// Register: RD_VGPIO2 (0x91) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VGPIO2_EN bit field.
 * @return The 1-bit value of RD_VGPIO2_EN.
 */
uint16_t MP2790::RD_VGPIO2_EN() {
    throw std::runtime_error("Error: RD_VGPIO2_EN is write-only. Cannot read.");
}

// Register: RD_VGPIO1 (0x92) - Access: Write-Only (1)
/**
 * @brief Reads the RD_VGPIO1_EN bit field.
 * @return The 1-bit value of RD_VGPIO1_EN.
 */
uint16_t MP2790::RD_VGPIO1_EN() {
    throw std::runtime_error("Error: RD_VGPIO1_EN is write-only. Cannot read.");
}

// Register: RD_TDIE (0x93) - Access: Write-Only (1)
/**
 * @brief Reads the RD_TDIE_EN bit field.
 * @return The 1-bit value of RD_TDIE_EN.
 */
uint16_t MP2790::RD_TDIE_EN() {
    throw std::runtime_error("Error: RD_TDIE_EN is write-only. Cannot read.");
}

// Register: RD_V1P8 (0x94) - Access: Write-Only (1)
/**
 * @brief Reads the RD_V1P8_EN bit field.
 * @return The 1-bit value of RD_V1P8_EN.
 */
uint16_t MP2790::RD_V1P8_EN() {
    throw std::runtime_error("Error: RD_V1P8_EN is write-only. Cannot read.");
}

// Register: RD_V3P3 (0x95) - Access: Write-Only (1)
/**
 * @brief Reads the RD_V3P3_EN bit field.
 * @return The 1-bit value of RD_V3P3_EN.
 */
uint16_t MP2790::RD_V3P3_EN() {
    throw std::runtime_error("Error: RD_V3P3_EN is write-only. Cannot read.");
}

// Register: RD_V5 (0x96) - Access: Write-Only (1)
/**
 * @brief Reads the RD_V5_EN bit field.
 * @return The 1-bit value of RD_V5_EN.
 */
uint16_t MP2790::RD_V5_EN() {
    throw std::runtime_error("Error: RD_V5_EN is write-only. Cannot read.");
}

// Register: CC_STS (0x97) - Access: Write-Only (1)
/**
 * @brief Reads the CC_STS_EN bit field.
 * @return The 1-bit value of CC_STS_EN.
 */
uint16_t MP2790::CC_STS_EN() {
    throw std::runtime_error("Error: CC_STS_EN is write-only. Cannot read.");
}

// Register: ADC_STS (0x98) - Access: Write-Only (1)
/**
 * @brief Reads the ADC_STS_EN bit field.
 * @return The 1-bit value of ADC_STS_EN.
 */
uint16_t MP2790::ADC_STS_EN() {
    throw std::runtime_error("Error: ADC_STS_EN is write-only. Cannot read.");
}

// Register: ADC_CTRL (0x99) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the ADC_CTRL_EN bit field.
 * @return The 1-bit value of ADC_CTRL_EN.
 */
uint16_t MP2790::ADC_CTRL_EN() {
    return readBitField(ADC_CTRL, ADC_CTRL_EN_SB, ADC_CTRL_EN_LEN);
}
/**
 * @brief Writes to the ADC_CTRL_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::ADC_CTRL_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for ADC_CTRL_EN. Expected MTP mode.");
    }
    writeBitField(ADC_CTRL, ADC_CTRL_EN_SB, ADC_CTRL_EN_LEN, value);
}

// Register: CC_CFG (0x9A) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the CC_CFG_EN bit field.
 * @return The 1-bit value of CC_CFG_EN.
 */
uint16_t MP2790::CC_CFG_EN() {
    return readBitField(CC_CFG, CC_CFG_EN_SB, CC_CFG_EN_LEN);
}
/**
 * @brief Writes to the CC_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::CC_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for CC_CFG_EN. Expected MTP mode.");
    }
    writeBitField(CC_CFG, CC_CFG_EN_SB, CC_CFG_EN_LEN, value);
}

// Register: TRIMG_IPCB (0x9B) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the TRIMG_IPCB_EN bit field.
 * @return The 1-bit value of TRIMG_IPCB_EN.
 */
uint16_t MP2790::TRIMG_IPCB_EN() {
    return readBitField(TRIMG_IPCB, TRIMG_IPCB_EN_SB, TRIMG_IPCB_EN_LEN);
}
/**
 * @brief Writes to the TRIMG_IPCB_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::TRIMG_IPCB_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for TRIMG_IPCB_EN. Expected MTP mode.");
    }
    writeBitField(TRIMG_IPCB, TRIMG_IPCB_EN_SB, TRIMG_IPCB_EN_LEN, value);
}

// Register: HR_SCAN0 (0x9C) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the HR_SCAN0_EN bit field.
 * @return The 1-bit value of HR_SCAN0_EN.
 */
uint16_t MP2790::HR_SCAN0_EN() {
    return readBitField(HR_SCAN0, HR_SCAN0_EN_SB, HR_SCAN0_EN_LEN);
}
/**
 * @brief Writes to the HR_SCAN0_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::HR_SCAN0_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for HR_SCAN0_EN. Expected MTP mode.");
    }
    writeBitField(HR_SCAN0, HR_SCAN0_EN_SB, HR_SCAN0_EN_LEN, value);
}

// Register: HR_SCAN1 (0x9D) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the HR_SCAN1_EN bit field.
 * @return The 1-bit value of HR_SCAN1_EN.
 */
uint16_t MP2790::HR_SCAN1_EN() {
    return readBitField(HR_SCAN1, HR_SCAN1_EN_SB, HR_SCAN1_EN_LEN);
}
/**
 * @brief Writes to the HR_SCAN1_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::HR_SCAN1_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for HR_SCAN1_EN. Expected MTP mode.");
    }
    writeBitField(HR_SCAN1, HR_SCAN1_EN_SB, HR_SCAN1_EN_LEN, value);
}

// Register: HR_SCAN2 (0x9E) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the HR_SCAN2_EN bit field.
 * @return The 1-bit value of HR_SCAN2_EN.
 */
uint16_t MP2790::HR_SCAN2_EN() {
    return readBitField(HR_SCAN2, HR_SCAN2_EN_SB, HR_SCAN2_EN_LEN);
}
/**
 * @brief Writes to the HR_SCAN2_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::HR_SCAN2_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for HR_SCAN2_EN. Expected MTP mode.");
    }
    writeBitField(HR_SCAN2, HR_SCAN2_EN_SB, HR_SCAN2_EN_LEN, value);
}

// Register: SILC_INFO1 (0xA0) - Access: Write-Only (1)
/**
 * @brief Reads the SILC_INFO1_EN bit field.
 * @return The 1-bit value of SILC_INFO1_EN.
 */
uint16_t MP2790::SILC_INFO1_EN() {
    throw std::runtime_error("Error: SILC_INFO1_EN is write-only. Cannot read.");
}

// Register: COMM_CFG (0xA3) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the COMM_CFG_EN bit field.
 * @return The 1-bit value of COMM_CFG_EN.
 */
uint16_t MP2790::COMM_CFG_EN() {
    return readBitField(COMM_CFG, COMM_CFG_EN_SB, COMM_CFG_EN_LEN);
}
/**
 * @brief Writes to the COMM_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::COMM_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for COMM_CFG_EN. Expected MTP mode.");
    }
    writeBitField(COMM_CFG, COMM_CFG_EN_SB, COMM_CFG_EN_LEN, value);
}

// Register: BAL_STS (0xA4) - Access: Write-Only (1)
/**
 * @brief Reads the BAL_STS_EN bit field.
 * @return The 1-bit value of BAL_STS_EN.
 */
uint16_t MP2790::BAL_STS_EN() {
    throw std::runtime_error("Error: BAL_STS_EN is write-only. Cannot read.");
}

// Register: BAL_LIST (0xA5) - Access: Write-Only (1)
/**
 * @brief Reads the BAL_LIST_EN bit field.
 * @return The 1-bit value of BAL_LIST_EN.
 */
uint16_t MP2790::BAL_LIST_EN() {
    throw std::runtime_error("Error: BAL_LIST_EN is write-only. Cannot read.");
}

// Register: BAL_CTRL (0xA6) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the BAL_CTRL_EN bit field.
 * @return The 1-bit value of BAL_CTRL_EN.
 */
uint16_t MP2790::BAL_CTRL_EN() {
    return readBitField(BAL_CTRL, BAL_CTRL_EN_SB, BAL_CTRL_EN_LEN);
}
/**
 * @brief Writes to the BAL_CTRL_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::BAL_CTRL_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for BAL_CTRL_EN. Expected MTP mode.");
    }
    writeBitField(BAL_CTRL, BAL_CTRL_EN_SB, BAL_CTRL_EN_LEN, value);
}

// Register: BAL_CFG (0xA7) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the BAL_CFG_EN bit field.
 * @return The 1-bit value of BAL_CFG_EN.
 */
uint16_t MP2790::BAL_CFG_EN() {
    return readBitField(BAL_CFG, BAL_CFG_EN_SB, BAL_CFG_EN_LEN);
}
/**
 * @brief Writes to the BAL_CFG_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::BAL_CFG_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for BAL_CFG_EN. Expected MTP mode.");
    }
    writeBitField(BAL_CFG, BAL_CFG_EN_SB, BAL_CFG_EN_LEN, value);
}

// Register: BAL_THR (0xA8) - Access: Read/Write (2), NVM: MTP
/**
 * @brief Reads the BAL_THR_EN bit field.
 * @return The 1-bit value of BAL_THR_EN.
 */
uint16_t MP2790::BAL_THR_EN() {
    return readBitField(BAL_THR, BAL_THR_EN_SB, BAL_THR_EN_LEN);
}
/**
 * @brief Writes to the BAL_THR_EN bit field (MTP capable).
 * @param value The 1-bit value to write.
 * @param nvmAccessMode The access mode required for MTP programming.
 */
void MP2790::BAL_THR_EN(uint16_t value, uint16_t nvmAccessMode) {
    if (nvmAccessMode != NVM_ACCESS_MODE_MTP) {
        throw std::runtime_error("Invalid NVM access mode for BAL_THR_EN. Expected MTP mode.");
    }
    writeBitField(BAL_THR, BAL_THR_EN_SB, BAL_THR_EN_LEN, value);
}

// Register: MEM_STATUS (0xB4) - Access: Write-Only (1)
/**
 * @brief Reads the MEM_STATUS_EN bit field.
 * @return The 1-bit value of MEM_STATUS_EN.
 */
uint16_t MP2790::MEM_STATUS_EN() {
    throw std::runtime_error("Error: MEM_STATUS_EN is write-only. Cannot read.");
}

// Register: OTP_STORE_CMD (0xB8) - Access: Read/Write (2), NVM: OTP
/**
 * @brief Reads the OTP_STORE_CMD_EN bit field.
 * @return The 1-bit value of OTP_STORE_CMD_EN.
 */
uint16_t MP2790::OTP_STORE_CMD_EN() {
    return readBitField(OTP_STORE_CMD, OTP_STORE_CMD_EN_SB, OTP_STORE_CMD_EN_LEN);
}
/**
 * @brief Writes to the OTP_STORE_CMD_EN bit field (OTP capabl